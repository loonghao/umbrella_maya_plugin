//! Raw FFI bindings to Maya C++ API
//! 
//! This module provides direct, unsafe access to Maya's C++ API.
//! These bindings are generated by bindgen and should not be used directly.
//! Use the safe wrappers in the `safe` module instead.

use std::os::raw::{c_char, c_int, c_void, c_double};

// Re-export the generated bindings
pub use crate::ffi::bindings::*;

/// Maya status codes
pub mod status_codes {
    use super::c_int;
    
    /// Success status code
    pub const MS_SUCCESS: c_int = 0;
    /// Generic failure status code
    pub const MS_FAILURE: c_int = 1;
    /// Unknown object status code
    pub const MS_UNKNOWN_OBJECT: c_int = 2;
    /// Invalid parameter status code
    pub const MS_INVALID_PARAMETER: c_int = 3;
    /// Command unknown status code
    pub const MS_COMMAND_UNKNOWN: c_int = 4;
    /// Command not parsable status code
    pub const MS_COMMAND_NOT_PARSABLE: c_int = 5;
}

/// Maya object types
pub mod object_types {
    use super::c_int;

    /// Unknown object type
    pub const MOBJECT_NULL: c_int = 0;
    /// Dependency node type
    pub const MOBJECT_DEPENDENCY_NODE: c_int = 1;
    /// DAG node type
    pub const MOBJECT_DAG_NODE: c_int = 2;
    /// Component type
    pub const MOBJECT_COMPONENT: c_int = 3;
}

/// Forward declarations for types that may not be available in placeholder bindings
#[cfg(not(feature = "maya_bindings"))]
mod forward_decls {
    use std::os::raw::c_void;

    /// Placeholder MPxCommand type
    #[repr(C)]
    pub struct MPxCommand {
        _private: [u8; 0],
    }

    /// Placeholder MArgList type
    #[repr(C)]
    pub struct MArgList {
        _private: [u8; 0],
    }
}

#[cfg(not(feature = "maya_bindings"))]
pub use forward_decls::*;

// Raw Maya API function declarations
// These functions provide direct access to Maya's C++ API.
// They are unsafe and should be wrapped in safe Rust functions.
extern "C" {
    // MObject functions
    pub fn MObject_create() -> MObject;
    pub fn MObject_isNull(obj: *const MObject) -> bool;
    pub fn MObject_isValid(obj: *const MObject) -> bool;
    pub fn MObject_apiType(obj: *const MObject) -> c_int;

    // MStatus functions
    pub fn MStatus_success() -> MStatus;
    pub fn MStatus_error(code: c_int) -> MStatus;
    pub fn MStatus_isSuccess(status: *const MStatus) -> bool;
    pub fn MStatus_statusCode(status: *const MStatus) -> c_int;

    // MString functions
    pub fn MString_create() -> MString;
    pub fn MString_createFromCStr(str: *const c_char) -> MString;
    pub fn MString_asCStr(str: *const MString) -> *const c_char;
    pub fn MString_length(str: *const MString) -> c_int;
    pub fn MString_destroy(str: *mut MString);

    // MFnPlugin functions
    pub fn MFnPlugin_create(obj: MObject) -> MFnPlugin;
    pub fn MFnPlugin_registerCommand(
        plugin: *mut MFnPlugin,
        command_name: *const c_char,
        creator_fn: *const c_void,
    ) -> MStatus;
    pub fn MFnPlugin_deregisterCommand(
        plugin: *mut MFnPlugin,
        command_name: *const c_char,
    ) -> MStatus;
    pub fn MFnPlugin_setApiVersion(
        plugin: *mut MFnPlugin,
        version: *const c_char,
    ) -> MStatus;

    // MPxCommand functions (using void pointers for placeholder compatibility)
    pub fn MPxCommand_create() -> *mut c_void;
    pub fn MPxCommand_doIt(
        command: *mut c_void,
        args: *const c_void,
    ) -> MStatus;
    pub fn MPxCommand_undoIt(command: *mut c_void) -> MStatus;
    pub fn MPxCommand_isUndoable(command: *const c_void) -> bool;

    // MArgList functions (using void pointers for placeholder compatibility)
    pub fn MArgList_length(args: *const c_void) -> c_int;
    pub fn MArgList_asString(
        args: *const c_void,
        index: c_int,
        status: *mut MStatus,
    ) -> MString;
    pub fn MArgList_asInt(
        args: *const c_void,
        index: c_int,
        status: *mut MStatus,
    ) -> c_int;
    pub fn MArgList_asDouble(
        args: *const c_void,
        index: c_int,
        status: *mut MStatus,
    ) -> c_double;

    // Plugin entry points
    pub fn initializePlugin(obj: MObject) -> MStatus;
    pub fn uninitializePlugin(obj: MObject) -> MStatus;
}

/// Helper macros for working with Maya status codes
#[macro_export]
macro_rules! maya_check_status {
    ($status:expr) => {
        if !MStatus_isSuccess(&$status) {
            return Err(crate::error::UmbrellaError::MayaApi(format!(
                "Maya operation failed with status code: {}",
                MStatus_statusCode(&$status)
            )));
        }
    };
}

/// Helper macro for creating Maya status results
#[macro_export]
macro_rules! maya_status_result {
    ($expr:expr) => {{
        let status = $expr;
        if MStatus_isSuccess(&status) {
            Ok(())
        } else {
            Err(crate::error::UmbrellaError::MayaApi(format!(
                "Maya operation failed with status code: {}",
                MStatus_statusCode(&status)
            )))
        }
    }};
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_status_codes() {
        assert_eq!(status_codes::MS_SUCCESS, 0);
        assert_eq!(status_codes::MS_FAILURE, 1);
    }

    #[test]
    fn test_object_types() {
        assert_eq!(object_types::MOBJECT_NULL, 0);
        assert_eq!(object_types::MOBJECT_DEPENDENCY_NODE, 1);
    }
}
